// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/*
  zkVerifierManager.sol
  - Keeps a mapping of user commitments -> lastGroup
  - Accepts proof verification calls and updates mapped group on success.
  - Uses a Verifier contract (generated by snarkjs).
*/

interface IVerifier {
    function verifyProof(bytes memory proof, uint[] memory pubSignals) external view returns (bool);
}

contract zkVerifierManager {
    IVerifier public verifier;
    address public owner;

    // commitment -> last public group id
    mapping(bytes32 => uint8) public lastGroup;

    event ProofAccepted(bytes32 indexed commitment, uint8 groupId, address indexed sender);

    constructor(address _verifier) {
        verifier = IVerifier(_verifier);
        owner = msg.sender;
    }

    // This function accepts: proof bytes & public signals (as ints).
    // For groth16, verifyProof expects a different signature in generated contract; here we use an abstract IVerifier for clarity.
    function submitProof(bytes calldata proof, uint[] calldata pubSignals, bytes32 commitment) external {
        bool ok = verifier.verifyProof(proof, toUintArray(pubSignals));
        require(ok, "invalid proof");

        // pubSignals[0] expected to be group id (small integer)
        uint8 groupId = uint8(pubSignals[0]);
        lastGroup[commitment] = groupId;

        emit ProofAccepted(commitment, groupId, msg.sender);
    }

    // helper to convert calldata -> memory
    function toUintArray(uint[] calldata arr) internal pure returns (uint[] memory out) {
        out = new uint[](arr.length);
        for (uint i = 0; i < arr.length; i++) out[i] = arr[i];
    }
}
